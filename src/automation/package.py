# -*- coding: utf-8 -*-
#
# Copyright Â© 2021 Genome Research Ltd. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# @author Michael Kubiak <mk53@sanger.ac.uk>

from __future__ import annotations

import logging as log
import re
from pathlib import Path
from typing import List, Set, Tuple

import conda.base.context
from conda.cli.python_api import Commands, run_command

from recipebook.recipebook import RecipeBook


class Package:
    """A package is the output of a conda recipe, with a name, version number,
    and any number of sub-packages (including zero).

    Packages having the same name and version are equal. Packages sort
    lexically, on their name first, then on their version, if names are equal.
    """

    _name: str
    _version: str
    _sub_packages: set

    def __init__(self, nv: Tuple[str, str], recipebook: RecipeBook = None):
        self._name = nv[0]
        self._version = nv[1]
        self._recipebook = recipebook
        self._sub_packages = set()

        if self._recipebook:
            self._sub_packages = self._recipebook.get_sub_packages(nv)

    def __hash__(self):
        return hash(self._name) + hash(self._version)

    def __eq__(self, other):
        if type(other) is type(self):
            return (self.name() == other.name() and
                    self.version() == other.version())
        return False

    def __lt__(self, other):
        if type(other) is type(self):
            if self.name() < other.name():
                return True
            if self.version() < other.version():
                return True
        return False

    def __repr__(self):
        return str(self.nv())

    def __str__(self):
        return "{}={}".format(self.name(), self.version())

    def name(self) -> str:
        return self._name

    def version(self) -> str:
        return self._version

    def nv(self) -> Tuple[str, str]:
        return self._name, self._version

    def sub_packages(self) -> Set[str]:
        """Returns a list of subpackages of the package

        Returns: Set[str]

        """
        if not self._recipebook:
            raise PackageError("Cannot determine sub-packages because no "
                               "recipe book is associated with this Package")
        return self._sub_packages

    def get_test_scripts(self) -> List[str]:
        """Returns a list of the conda-build test scripts that are installed
        for the package. These scripts are generated by conda-build from the
        recipe metadata, or are provided by the package author. They are
        installed in a Conda environment as part of the package.

        Returns: List[str]

        """
        ctx = conda.base.context.Context()
        if ctx.root_dir is None:
            raise PackageError("Unable to locate the installed test scripts "
                               f"of {self} because Conda is not activated")

        conda_root = Path(ctx.root_dir)
        test_scripts = []
        glob_pattern = "pkgs/{}-{}*/info/test/run_test.*"

        log.debug("Finding test scripts under {}".format(conda_root))
        if self.sub_packages():
            for sub in self.sub_packages():
                scripts = list(conda_root.glob(
                    glob_pattern.format(sub, self.version())))
                log.debug("Found {} test scripts "
                          "for {}".format(len(scripts), sub))
                test_scripts.extend(scripts)
        else:
            scripts = list(conda_root.glob(
                glob_pattern.format(self.name(), self.version())))
            log.debug("Found {} test scripts "
                      "for {}".format(len(scripts), self.name()))
            test_scripts.extend(scripts)

        return [str(script) for script in test_scripts]

    def run_test_scripts(self, env: str):
        """Runs the test scripts returned by the get_test_scripts method, in
        the specified Conda environment. Although designed to be run at
        build-time, these scripts have proved useful when run post-install.
        They allow detection of regressions, such as undocumented
        incompatibilities between packages.

        Args:
            env: The environment in which to run the test scripts.
        """
        test_scripts = self.get_test_scripts()
        failures = {}

        for script in test_scripts:
            _, stderr, code = run_command(Commands.RUN, "-n", env,
                                          "/bin/bash", script)
            if code > 0:
                failures[script] = stderr

        if failures:
            raise FailedTestError("{}".format(failures))

    # TODO: it may be possible to find library names in recipes,
    #  rather than assuming that they contain the package name
    def check_ldd(self, path: str, env: str):
        """Run ldd on executables and libraries in a path, and find uses of a
        system version of libraries containing the package name

        Args:
            path: The path to a directory of (or a single) executables or
                    libraries
            env: The conda environment in which to run ldd
        """

        # '|| exit 0' prevents ldd from failing due to non executables
        stdout, stderr, code = run_command(Commands.RUN, "-n", env, "ldd",
                                           path, "||", "exit", "0")
        log.debug(f"ldd stdout: '{stdout}', stderr: '{stderr}', code: {code}")
        for line in stdout.split("\n"):
            if re.search(".*/usr/lib/.*", line):
                if self.sub_packages():
                    for sub in self.sub_packages():
                        if re.search(f'.*{sub}.*', line):
                            raise LibError(line)
                else:
                    if re.search(f".*{self.name()}.*", line):
                        raise LibError(line)


class PackageError(Exception):
    """Raise when an error occurs building, testing or managing a Conda
    package."""
    pass


class FailedTestError(PackageError):
    """
    Raise when a test script fails.
    """
    pass


class LibError(PackageError):
    """
    Raise when a library or executable is pulling in the wrong version of a
    library.
    """
    pass
